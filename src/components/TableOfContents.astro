---
export interface Props {
  html: string;
}

// html prop is passed but not used server-side, TOC is built client-side
---

<aside
  id="table-of-contents"
  class="hidden xl:block
    fixed right-8 top-24
    w-64 max-h-[calc(100vh-6rem)]
    transition-all duration-500 ease-in-out
    opacity-0 translate-x-4"
>
  <div
    class="overflow-y-auto scrollbar-thin scrollbar-track-transparent scrollbar-thumb-gray-300 dark:scrollbar-thumb-gray-600"
  >
    <h3
      class="text-sm font-semibold text-skin-base uppercase tracking-wide mb-4"
    >
      ON THIS PAGE
    </h3>

    <nav role="navigation" aria-label="目次">
      <ul class="flex flex-col gap-2 border-l border-skin-line">
        <!-- TOC items will be dynamically generated by JavaScript -->
      </ul>
    </nav>
  </div>
</aside>

<script>
  // Extend Window interface for cleanup function
  declare global {
    interface Window {
      tocCleanup?: () => void;
    }
  }

  function initializeTOC() {
    const toc = document.getElementById("table-of-contents");
    if (!toc) return;

    // Get all headings from the article
    const actualHeadings = Array.from(
      document.querySelectorAll("#article h2, #article h3, #article h4")
    );

    if (actualHeadings.length === 0) {
      return;
    }

    // Build TOC dynamically
    const tocContainer = toc.querySelector("nav ul");
    if (tocContainer) {
      tocContainer.innerHTML = actualHeadings
        .map((heading, index) => {
          const id = heading.id || `heading-${index}`;
          if (!heading.id) heading.id = id; // Assign ID if missing

          // Remove # characters from the heading text
          const rawText = heading.textContent || `Heading ${index + 1}`;
          const text = rawText
            .replace(/^#+\s*/, "") // Remove leading #
            .replace(/\s*#+$/g, "") // Remove trailing # (with or without spaces)
            .replace(/#$/g, "") // Remove any remaining trailing #
            .trim();
          const level = parseInt(heading.tagName.charAt(1));

          const paddingClass =
            level === 2
              ? "pl-5 sm:pl-4"
              : level === 3
                ? "pl-7 sm:pl-6"
                : "pl-10 sm:pl-9";

          return `
          <li class="-ml-px flex flex-col items-start gap-2">
            <a
              href="#${id}"
              data-heading-id="${id}"
              class="toc-link inline-block border-l border-transparent text-sm/6 transition-all duration-200 ease-in-out focus:outline-none ${paddingClass} text-skin-base/70 hover:border-skin-accent/25 hover:text-skin-base"
            >
              ${text}
            </a>
          </li>
        `;
        })
        .join("");
    }

    // Show TOC with fade-in animation
    setTimeout(() => {
      toc.classList.remove("opacity-0", "translate-x-4");
      toc.classList.add("opacity-100", "translate-x-0");
    }, 300);

    // Re-query TOC links and headings after building them
    const tocLinks = document.querySelectorAll(".toc-link");
    const headings = Array.from(
      document.querySelectorAll(
        "#article h2[id], #article h3[id], #article h4[id]"
      )
    );
    let activeId = "";

    if (headings.length === 0) {
      return;
    }

    // Intersection Observer for scroll spy
    const observer = new IntersectionObserver(
      entries => {
        const visibleEntries = entries.filter(entry => entry.isIntersecting);
        if (visibleEntries.length > 0) {
          const topEntry = visibleEntries.reduce((top, entry) =>
            entry.boundingClientRect.top < top.boundingClientRect.top
              ? entry
              : top
          );

          const newActiveId = topEntry.target.id;
          if (newActiveId !== activeId) {
            updateActiveLink(newActiveId);
            activeId = newActiveId;
          }
        }
      },
      {
        rootMargin: "0% 0% -60% 0%", // Less strict margin for better detection
        threshold: 0,
      }
    );

    // Additional scroll listener to handle edge cases (like last section)
    let scrollTimeout: number;
    function handleScroll() {
      clearTimeout(scrollTimeout);
      scrollTimeout = window.setTimeout(() => {
        // Check if we're near the bottom of the page
        const isNearBottom =
          window.innerHeight + window.scrollY >=
          document.body.offsetHeight - 100;

        if (isNearBottom && headings.length > 0) {
          // If near bottom, activate the last heading
          const lastHeading = headings[headings.length - 1] as HTMLElement;
          if (lastHeading && lastHeading.id !== activeId) {
            updateActiveLink(lastHeading.id);
            activeId = lastHeading.id;
          }
        }
      }, 100);
    }

    window.addEventListener("scroll", handleScroll, { passive: true });

    // Observe all headings
    headings.forEach(heading => observer.observe(heading));

    // Update active link styling
    function updateActiveLink(newActiveId: string) {
      tocLinks.forEach(link => {
        link.classList.remove("border-l-skin-accent", "text-skin-accent");
        link.classList.add("text-skin-base/70");
        link.removeAttribute("aria-current");
      });

      const activeLink = document.querySelector(
        `[data-heading-id="${newActiveId}"]`
      );
      if (activeLink) {
        activeLink.classList.add("border-l-skin-accent", "text-skin-accent");
        activeLink.classList.remove("text-skin-base/70");
        activeLink.setAttribute("aria-current", "location");
      }
    }

    // Handle smooth scroll to section
    tocLinks.forEach(link => {
      link.addEventListener(
        "click",
        function (this: HTMLAnchorElement, e: Event) {
          e.preventDefault();
          const headingId = this.getAttribute("data-heading-id");
          const element = headingId ? document.getElementById(headingId) : null;

          if (element) {
            element.scrollIntoView({
              behavior: "smooth",
              block: "start",
            });
            window.history.replaceState(null, "", `#${headingId}`);
          }
        }
      );
    });

    // Store cleanup functions globally
    window.tocCleanup = () => {
      observer.disconnect();
      window.removeEventListener("scroll", handleScroll);
    };
  }

  // Initialize on DOM ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initializeTOC);
  } else {
    initializeTOC();
  }

  // Re-initialize after Astro page transitions
  document.addEventListener("astro:page-load", function () {
    // Clean up previous observers and listeners
    if (window.tocCleanup) {
      window.tocCleanup();
    }
    // Re-initialize
    initializeTOC();
  });
</script>
